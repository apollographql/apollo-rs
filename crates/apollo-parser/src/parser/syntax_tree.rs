use std::fmt;

use miette::{Diagnostic, NamedSource, SourceSpan};
use rowan::GreenNodeBuilder;
use thiserror::Error;

use crate::{ast::Document, Error, SyntaxElement, SyntaxKind};

use super::GraphQLLanguage;

#[derive(Error, Debug, Diagnostic)]
#[error("{}", self.ty)]
#[diagnostic(code("parsing error found"))]
struct ApolloParserError {
    ty: String,
    #[source_code]
    src: NamedSource,
    #[label("{}", self.ty)]
    span: SourceSpan,
}
/// An AST generated by the parser.
pub struct SyntaxTree {
    pub(crate) ast: rowan::SyntaxNode<GraphQLLanguage>,
    pub(crate) errors: Vec<crate::Error>,
}

impl SyntaxTree {
    /// Get a reference to the syntax tree's errors.
    pub fn errors(&self) -> &[crate::Error] {
        self.errors.as_slice()
    }

    /// Return the root typed `Document` node.
    pub fn document(self) -> Document {
        Document { syntax: self.ast }
    }

    pub fn pretty_print_errors(&self) {
        for err in self.errors().into_iter().rev() {
            println!(
                "{}",
                ApolloParserError {
                    src: NamedSource::new("schema.graphql", self.as_string()),
                    span: (err.index(), err.data().len()).into(),
                    ty: err.message().into(),
                }
            );
        }
    }

    pub fn as_string(&self) -> String {
        let element = self.ast.clone().into();
        let data: Vec<(usize, &str)> = self
            .errors
            .iter()
            .map(|err| (err.index, err.data().clone()))
            .collect();
        let mut data = Self::data_index_pairs(element, data);
        data.sort_by(|a, b| a.0.cmp(&b.0));
        data.into_iter().map(|item| item.1).collect()
    }

    fn data_index_pairs(
        element: SyntaxElement,
        mut data: Vec<(usize, &str)>,
    ) -> Vec<(usize, &str)> {
        match element {
            rowan::NodeOrToken::Node(node) => {
                for child in node.children_with_tokens() {
                    return Self::data_index_pairs(child, data);
                }
            }
            rowan::NodeOrToken::Token(token) => data.push((token.index(), token.text())),
        }
        data
    }
}

impl fmt::Debug for SyntaxTree {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fn print(f: &mut fmt::Formatter<'_>, indent: usize, element: SyntaxElement) -> fmt::Result {
            let kind: SyntaxKind = element.kind();
            write!(f, "{:indent$}", "", indent = indent)?;
            match element {
                rowan::NodeOrToken::Node(node) => {
                    writeln!(f, "- {:?}@{:?}", kind, node.text_range())?;
                    for child in node.children_with_tokens() {
                        print(f, indent + 4, child)?;
                    }
                    Ok(())
                }

                rowan::NodeOrToken::Token(token) => {
                    writeln!(
                        f,
                        "- {:?}@{:?} {:?}",
                        kind,
                        token.text_range(),
                        token.text()
                    )
                }
            }
        }

        fn print_err(f: &mut fmt::Formatter<'_>, errors: Vec<Error>) -> fmt::Result {
            for err in errors {
                writeln!(f, "- {:?}", err)?;
            }

            write!(f, "")
        }

        print(f, 0, self.ast.clone().into())?;
        print_err(f, self.errors.clone())
    }
}

#[derive(Debug)]
pub(crate) struct SyntaxTreeBuilder {
    builder: GreenNodeBuilder<'static>,
}

impl SyntaxTreeBuilder {
    /// Create a new instance of `SyntaxBuilder`.
    pub(crate) fn new() -> Self {
        Self {
            builder: GreenNodeBuilder::new(),
        }
    }

    /// Start new node and make it current.
    pub(crate) fn start_node(&mut self, kind: SyntaxKind) {
        self.builder.start_node(rowan::SyntaxKind(kind as u16));
    }

    /// Finish current branch and restore previous branch as current.
    pub(crate) fn finish_node(&mut self) {
        self.builder.finish_node();
    }

    /// Adds new token to the current branch.
    pub(crate) fn token(&mut self, kind: SyntaxKind, text: &str) {
        self.builder.token(rowan::SyntaxKind(kind as u16), text);
    }

    pub(crate) fn finish(self, errors: Vec<Error>) -> SyntaxTree {
        SyntaxTree {
            ast: rowan::SyntaxNode::new_root(self.builder.finish()),
            // TODO: keep the errors in the builder rather than pass it in here?
            errors,
        }
    }
}

#[cfg(test)]
mod test {
    use crate::ast::Definition;
    use crate::Parser;

    #[test]
    fn schema_with_errors() {
        let input = "directive @example(isTreat: Boolean, treatKind: * String) on";
        let parser = Parser::new(input);
        let ast = parser.parse();

        if !ast.errors().is_empty() {
            ast.pretty_print_errors();
        }

        let doc = ast.document();

        for def in doc.definitions() {
            if let Definition::DirectiveDefinition(directive) = def {
                assert_eq!(directive.name().unwrap().text(), "example");
            }
        }
    }

    #[test]
    fn directive_name() {
        let input = "directive @example(isTreat: Boolean, treatKind: String) on FIELD | MUTATION";
        let parser = Parser::new(input);
        let ast = parser.parse();

        if !ast.errors().is_empty() {
            ast.pretty_print_errors();
        }

        let doc = ast.document();

        for def in doc.definitions() {
            if let Definition::DirectiveDefinition(directive) = def {
                assert_eq!(directive.name().unwrap().text(), "example");
            }
        }
    }

    #[test]
    fn object_type_definition() {
        let input = "
        type ProductDimension {
          size: String
          weight: Float @tag(name: \"hi from inventory value type field\")
        }
        ";
        let parser = Parser::new(input);
        let ast = parser.parse();
        assert!(ast.errors().is_empty());

        let doc = ast.document();

        for def in doc.definitions() {
            if let Definition::ObjectTypeDefinition(object_type) = def {
                assert_eq!(object_type.name().unwrap().text(), "ProductDimension");
                for field_def in object_type.fields_definition().unwrap().field_definitions() {
                    println!("{}", field_def.name().unwrap().text()); // size weight
                }
            }
        }
    }
}
